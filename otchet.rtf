{\rtf1\ansi\ansicpg1251\deff0\nouicompat\deflang1049{\fonttbl{\f0\fnil\fcharset204 Arial;}{\f1\fnil\fcharset0 Arial;}{\f2\fnil\fcharset1 Segoe UI Symbol;}{\f3\fnil\fcharset204 Times New Roman;}{\f4\fnil\fcharset0 Times New Roman;}{\f5\fnil\fcharset0 Consolas;}{\f6\fnil\fcharset0 Calibri;}{\f7\fnil\fcharset204 Calibri;}{\f8\fnil\fcharset204 Calibri Light;}}
{\colortbl ;\red0\green0\blue0;\red255\green255\blue255;\red128\green128\blue128;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sl240\slmult1\qc\cf1\highlight2\f0\fs21\'d4\'e5\'e4\'e5\'f0\'e0\'eb\'fc\'ed\'ee\'e5 \'e3\'ee\'f1\'f3\'e4\'e0\'f0\'f1\'f2\'e2\'e5\'ed\'ed\'ee\'e5 \'e1\'fe\'e4\'e6\'e5\'f2\'ed\'ee\'e5 \'ee\'e1\'f0\'e0\'e7\'ee\'e2\'e0\'f2\'e5\'eb\'fc\'ed\'ee\'e5 \'f3\'f7\'f0\'e5\'e6\'e4\'e5\'ed\'e8\'e5 \'e2\'fb\'f1\'f8\'e5\'e3\'ee \'ee\'e1\'f0\'e0\'e7\'ee\'e2\'e0\'ed\'e8\'ff \f1\lang1033\'ab\f0\lang1049\'cd\'e0\'f6\'e8\'ee\'ed\'e0\'eb\'fc\'ed\'fb\'e9 \'e8\'f1\'f1\'eb\'e5\'e4\'ee\'e2\'e0\'f2\'e5\'eb\'fc\'f1\'ea\'e8\'e9 \'f3\'ed\'e8\'e2\'e5\'f0\'f1\'e8\'f2\'e5\'f2 \f1\lang1033\'ab\f0\lang1049\'cc\'dd\'c8\f1\lang1033\'bb\par
\lang9\par
\f0\lang1049\'c8\'ed\'f1\'f2\'e8\'f2\'f3\'f2 \'e8\'ed\'f4\'ee\'f0\'ec\'e0\'f6\'e8\'ee\'ed\'ed\'fb\'f5 \'e8 \'e2\'fb\'f7\'e8\'f1\'eb\'e8\'f2\'e5\'eb\'fc\'ed\'fb\'f5 \'f2\'e5\'f5\'ed\'ee\'eb\'ee\'e3\'e8\'e9\par
\f1\lang9\par
\f0\lang1049\'ca\'e0\'f4\'e5\'e4\'f0\'e0 \'d3\'ef\'f0\'e0\'e2\'eb\'e5\'ed\'e8\'ff \'e8 \'e8\'ed\'f2\'e5\'eb\'eb\'e5\'ea\'f2\'f3\'e0\'eb\'fc\'ed\'fb\'f5 \'f2\'e5\'f5\'ed\'ee\'eb\'ee\'e3\'e8\'e9\par
\f1\lang9\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\b\f0\fs36\lang1049\'ce\'f2\'f7\'b8\'f2 \'ef\'ee \'eb\'e0\'e1\'ee\'f0\'e0\'f2\'ee\'f0\'ed\'ee\'e9 \'f0\'e0\'e1\'ee\'f2\'e5 \f2\u8470?\f1\lang1033  4\par

\pard\sb100\sa100\sl240\slmult1\qc\f0\lang1049\'cf\'ee \'ea\'f3\'f0\'f1\'f3 \f1\lang1033\'ab\highlight0\f0\lang1049\'d0\'e0\'e7\'f0\'e0\'e1\'ee\'f2\'ea\'e0 \'cf\'ce \'f1\'e8\'f1\'f2\'e5\'ec \'f3\'ef\'f0\'e0\'e2\'eb\'e5\'ed\'e8\'ff\f1\lang1033\'bb\par

\pard\sb100\sa100\sl240\slmult1\lang9         \'ab\f0\lang1049\'c1\'e8\'e1\'eb\'e8\'ee\'f2\'e5\'ea\'e8.\f3\fs48  \f0\fs36\'cd\'e8\'e7\'ea\'ee\'f3\'f0\'ee\'e2\'ed\'e5\'e2\'fb\'e5 \'ee\'ef\'e5\'f0\'e0\'f6\'e8\'e8\f1\lang1033\'bb\f4\fs48\par

\pard\sb100\sa100\sl240\slmult1\qc\b0\f1\fs28\lang9\par
\par

\pard\sb100\sa100\sl240\slmult1\par
\par

\pard\sb100\sa100\sl240\slmult1\qc\par

\pard\sb100\sa100\sl240\slmult1\qr\f0\fs21\lang1049\'c2\'fb\'ef\'ee\'eb\'ed\'e8\'eb \'f1\'f2\'f3\'e4\'e5\'ed\'f2 \'e3\'f0\'f3\'ef\'ef\'fb \'c0-02-20\par
\'d1\'e0\'e7\'ee\'ed\'ee\'e2\'e0 \'c2.\par
\'cf\'f0\'ee\'e2\'e5\'f0\'e8\'eb\'e8\par
\'cc\'ee\'f5\'ee\'e2\~\'c0.\~\'d1\par
\'ca\'ee\'e7\'eb\'fe\'ea\~\'c4.\~\'c0\par

\pard\sl240\slmult1\qc\cf3\f1\fs28\lang9\par
\par

\pard\sl240\slmult1\f5\fs19\par

\pard\sa160\sl256\slmult0\qc\cf0\f0\fs21\lang1049\'cc\'ee\'f1\'ea\'e2\'e0 2021\par

\pard\sa160\sl256\slmult0\cf1\i\f6\fs22\lang9\par
\cf0\i0\par
\cf1\b\fs27\par
\par
\par
\f7\lang1049\'c7\'e0\'e4\'e0\'ed\'e8\'e5.\par
\b0\f3\fs24\'c4\'ee\'e1\'e0\'e2\'e8\'f2\'fc \'e2\'ee\'e7\'ec\'ee\'e6\'ed\'ee\'f1\'f2\'fc \'ef\'ee\'f1\'f2\'f0\'ee\'e5\'ed\'e8\'ff \'e3\'e8\'f1\'f2\'ee\'e3\'f0\'e0\'ec\'ec\'fb \'ef\'ee \'e4\'e0\'ed\'ed\'fb\'ec \'e8\'e7 \'f4\'e0\'e9\'eb\'e0 \'e8\'e7 \'f1\'e5\'f2\'e8. \'c0\'e4\'f0\'e5\'f1 \'f4\'e0\'e9\'eb\'e0 \'e7\'e0\'e4\'e0\'e5\'f2\'f1\'ff \'e0\'f0\'e3\'f3\'ec\'e5\'ed\'f2\'ee\'ec \'ea\'ee\'ec\'e0\'ed\'e4\'ed\'ee\'e9 \'f1\'f2\'f0\'ee\'ea\'e8 \'ef\'f0\'ee\'e3\'f0\'e0\'ec\'ec\'fb. \'c5\'f1\'eb\'e8 \'e0\'e4\'f0\'e5\'f1 \'ed\'e5 \'e7\'e0\'e4\'e0\'ed, \'f7\'e8\'f2\'e0\'f2\'fc \'e4\'e0\'ed\'ed\'fb\'e5 \'f1\'ee \'f1\'f2\'e0\'ed\'e4\'e0\'f0\'f2\'ed\'ee\'e3\'ee \'e2\'e2\'ee\'e4\'e0, \'ea\'e0\'ea \'f0\'e0\'ed\'fc\'f8\'e5.\cf0\f7\par
\cf1\f3\'ca\'ee\'e4, \'ea\'ee\'f2\'ee\'f0\'fb\'e9 \'e1\'f3\'e4\'e5\'f2 \'ed\'e0\'ef\'e8\'f1\'e0\'ed \'e2 \'fd\'f2\'ee\'e9 \'f7\'e0\'f1\'f2\'e8 \'f0\'e0\'e1\'ee\'f2\'fb, \'e4\'ee\'eb\'e6\'e5\'ed \'e2 \'e8\'f2\'ee\'e3\'e5 \'f4\'ee\'f0\'ec\'e8\'f0\'ee\'e2\'e0\'f2\'fc \'f1\'f2\'f0\'ee\'ea\'f3, \'ea\'ee\'f2\'ee\'f0\'f3\'fe \'ed\'f3\'e6\'ed\'ee \'ee\'f2\'ee\'e1\'f0\'e0\'e7\'e8\'f2\'fc \'f1\'ed\'e8\'e7\'f3 \'e8\'f2\'ee\'e3\'ee\'e2\'ee\'e3\'ee SVG \'e2 \'f4\'ee\'f0\'ec\'e0\'f2\'e5:\cf0\f7\fs22\par
\cf1\f5\fs24\lang9 Windows v5.1 (build 1234)Computer name: My-Comp\cf0\f4\par
\cf1\i\f8\fs27\lang1049\'c2\'e0\'f0\'e8\'e0\'ed\'f2 16\par
\'d1 \'ef\'ee\'ec\'ee\'f9\'fc\'fe \'f4\'f3\'ed\'ea\'f6\'e8\'e8 curl_easy_getinfo() \'ef\'e5\'f7\'e0\'f2\'e0\'e9\'f2\'e5 \'ed\'e0 \'f1\'f2\'e0\'ed\'e4\'e0\'f0\'f2\'ed\'fb\'e9 \'e2\'fb\'e2\'ee\'e4 \'ee\'f8\'e8\'e1\'ee\'ea \'e2\'f0\'e5\'ec\'ff, \'e7\'e0\'f2\'f0\'e0\'f7\'e5\'ed\'ed\'ee\'e5 \'ed\'e0 \'f3\'f1\'f2\'e0\'ed\'ee\'e2\'ea\'f3 \'f1\'ee\'e5\'e4\'e8\'ed\'e5\'ed\'e8\'ff \'f1 \'f1\'e5\'f0\'e2\'e5\'f0\'ee\'ec (connect).\cf0\b\i0\f6\fs28\lang9\par
\cf1\b0\f7\fs27\lang1049\'ca\'ce\'c4 \'cf\'d0\'ce\'c3\'d0\'c0\'cc\'cc\'db \par
\b\i\f6\fs28\lang9 main.cpp\par
\par
\par
#include <iostream>\par
#include <vector>\par
#include "svg.h"\par
#include "histogram.h"\par
#include <curl/curl.h>\par
#include <string>\par
#include <sstream>\par
#include <Windows.h>\par
#include <windows.h>\par
#include <sstream>\par
#include <string>\par
\par
using namespace std;\par
\par
\par
const size_t SCREEN_WIDTH = 80;\par
const size_t MAX_ASTERISK = SCREEN_WIDTH - 4 - 1;\par
\par
vector<double>\par
input_numbers(istream& in, size_t count)\par
\{\par
vector<double> result(count);\par
for (size_t i = 0; i < count; i++)\par
\{\par
in \'bb result[i];\par
\}\par
return result;\par
\}\par
\par
\par
Input read_input(istream& in, bool prompt)\par
\{\par
Input data;\par
if (prompt)\par
\{\par
cerr << "Enter number count: ";\par
size_t number_count;\par
in >> number_count;\par
\par
cerr << "Enter numbers: ";\par
data.numbers = input_numbers(in, number_count);\par
\par
cerr << "Enter column count: ";\par
in >> data.bin_count;\par
\}\par
else\par
\{\par
size_t number_count;\par
in >> number_count;\par
data.numbers = input_numbers(in, number_count);\par
in >> data.bin_count;\par
\}\par
\par
return data;\par
\}\par
\par
size_t\par
write_data(void* items, size_t item_size, size_t item_count, void* ctx)\par
\{\par
\par
size_t data_size = item_size * item_count;\par
\par
stringstream* buffer = reinterpret_cast<stringstream*>(ctx);\par
buffer->write(reinterpret_cast<const char*>(items), data_size);\par
\par
return data_size;\par
\}\par
\par
Input\par
download(const string& address)\par
\{\par
\par
stringstream buffer;\par
curl_global_init(CURL_GLOBAL_ALL);\par
CURL *curl = curl_easy_init();\par
if(curl)\par
\{\par
CURLcode res;\par
double connect;\par
CURLcode ret;\par
curl_easy_setopt(curl, CURLOPT_URL, address.c_str());\par
curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);\par
curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);\par
curl_easy_setopt(curl, CURLOPT_WRITEDATA, &buffer);\par
res = curl_easy_perform(curl);\par
if(CURLE_OK == res)\par
\{\par
res = curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &connect);\par
if(CURLE_OK == res)\par
\{\par
cerr \'ab"Connect: " << connect;\par
\}\par
\}\par
curl_easy_cleanup(curl);\par
\par
if(res)\par
\{\par
cout << curl_easy_strerror(res);\par
exit(1);\par
\}\par
\}\par
\par
return read_input(buffer, false);\par
\}\par
int\par
main(int argc, char* argv[])\par
\{\par
Input input;\par
if (argc > 1)\par
\{\par
input = download(argv[1]);\par
\}\par
else\par
\{\par
input = read_input(cin, true);\par
\}\par
\par
const auto bins = make_histogram(input);\par
show_histogram_svg(bins);\par
\}\par
\par
\par
\par
\par
\lang1033 histogram.cpp\par
\par
\par
\par
#include <vector>\par
#include <iostream>\par
#include "histogram.h"\par
\par
using namespace std;\par
const size_t SCREEN_WIDTH = 80;\par
const size_t MAX_ASTERISK = SCREEN_WIDTH - 4 - 1;\par
\par
void find_minmax(const vector<double> numbers, double& min, double& max)\par
\{\par
    if (numbers.size() == 0) return;\par
    min = numbers[0];\par
    max = numbers[0];\par
    for (double number : numbers)\par
    \{\par
        if (number < min)\par
        \{\par
            min = number;\par
        \}\par
        if (number > max)\par
        \{\par
            max = number;\par
        \}\par
    \}\par
\par
\}\par
void\par
show_histogram_text(const vector<size_t>& bins)\par
\{\par
    size_t max_count = 0;\par
    for (size_t count : bins)\par
    \{\par
        if (count > max_count)\par
        \{\par
            max_count = count;\par
        \}\par
    \}\par
    const bool scaling_needed = max_count > MAX_ASTERISK;\par
\par
    for (size_t bin : bins)\par
    \{\par
        if (bin < 100)\par
        \{\par
            cout << ' ';\par
        \}\par
        if (bin < 10)\par
        \{\par
            cout << ' ';\par
        \}\par
        cout << bin << "|";\par
\par
        size_t height = bin;\par
        if (scaling_needed)\par
        \{\par
            const double scaling_factor = (double)MAX_ASTERISK / max_count;\par
            height = (size_t)(bin * scaling_factor);\par
        \}\par
\par
        for (size_t i = 0; i < height; i++)\par
        \{\par
            cout << '*';\par
        \}\par
        cout << '\\n';\par
    \}\par
\}\par
\par
vector<double> input_numbers(size_t count)\par
\{\par
    vector<double> result(count);\par
    for (size_t i = 0; i < count; i++) \{\par
        cin >> result[i];\par
    \}\par
    return result;\par
\}\par
\par
vector<size_t> make_histogram(Input data)\par
\{\par
    vector<size_t> result(data.bin_count);\par
    double min, max;\par
    find_minmax(data.numbers, min, max);\par
    for (double number : data.numbers)\par
    \{\par
        size_t bin = (size_t)((number - min) / (max - min) * data.bin_count);\par
        if (bin == data.bin_count)\par
        \{\par
            bin--;\par
        \}\par
        result[bin]++;\par
    \}\par
    return result;\par
\}\par
\par
\par
svg.cpp\par
\par
\par
\par
#include <iostream>\par
#include <vector>\par
#include "svg.h"\par
#include <windows.h>\par
#include <sstream>\par
#include <string>\par
using namespace std;\par
\par
\par
void\par
svg_begin(double width, double height)\par
\{\par
    cout << "<?xml version='1.0' encoding='UTF-8'?>\\n";\par
    cout << "<svg ";\par
    cout << "width='" << width << "' ";\par
    cout << "height='" << height << "' ";\par
    cout << "viewBox='0 0 " << width << " " << height << "' ";\par
    cout << "xmlns='http://www.w3.org/2000/svg'>\\n";\par
\}\par
\par
void\par
svg_end()\par
\{\par
    cout << "</svg>\\n";\par
\}\par
\par
void\par
svg_text(double left, double baseline, string text)\par
\{\par
\par
    cout << "<text x='" << left << "' y='"<< baseline <<"'>"<< text <<"</text>\\n";\par
\par
\}\par
\par
void svg_rect(double x, double y, double width, double height)\par
\{\par
    cout << "<rect x='"<< x <<"' y='"<< y <<"' width='"<< width <<"' height='"<< height <<"'/>\\n";\par
\}\par
\par
void svg_rect(double x, double y, double width, double height, string stroke, string fill )\par
\{\par
    cout << "<rect x='"<< x <<"' y='"<< y <<"' width='"<< width <<"' height='"<< height <<"' stroke='"<<stroke<<"' fill='"<< fill<<"'/>\\n";\par
\}\par
\par
void svg_rect(double x, double y, double width, double height, string stroke, string fill, double fill_opacity )\par
\{\par
    cout << "<rect x='"<< x <<"' y='"<< y <<"' width='"<< width <<"' height='"<< height <<"' stroke='"<<stroke<<"' fill='"<<\par
         fill<<"' fill-opacity ='"<< fill_opacity <<"'/>\\n";\par
\}\par
\par
double\par
opacity_factor (size_t bin, size_t max_count)\par
\{\par
    double opacity = (double)bin / max_count;\par
    if (max_count == 0)\par
        return 0;\par
        return opacity;\par
\}\par
\par
string\par
make_info_text()\par
\{\par
    stringstream buffer;\par
    DWORD WINAPI GetVersion(void);\par
\par
    DWORD info = GetVersion();\par
    DWORD mask = 0b00000000'00000000'11111111'11111111;\par
    DWORD version = info & mask;;\par
    DWORD platform = info >> 16;\par
    DWORD maska = 0b00000000'11111111;\par
    if ((info & 0x40000000) == 0)\par
    \{\par
        DWORD version_major = version & maska;\par
        DWORD version_minor = version >> 8;\par
        DWORD build = platform;\par
        buffer << "Windows v" << version_major << "." << version_minor << "(build " << build << ")\\n";\par
    \}\par
    DWORD size = MAX_COMPUTERNAME_LENGTH + 1;\par
    char pc_n[MAX_COMPUTERNAME_LENGTH + 1];\par
\par
    GetComputerNameA(pc_n, &size);\par
    buffer << "PC name: " << pc_n << '\\n';\par
    return buffer.str();\par
\}\par
\par
void\par
show_histogram_svg(const vector<size_t>& bins)\par
\{\par
    const auto IMAGE_WIDTH = 400;\par
    const auto IMAGE_HEIGHT = 300;\par
    const auto TEXT_LEFT = 20;\par
    const auto TEXT_BASELINE = 20;\par
    const auto TEXT_WIDTH = 50;\par
    const auto BIN_HEIGHT = 30;\par
    const auto BLOCK_WIDTH = 10;\par
    const auto MAX_COUNT = 34;\par
\par
    double top = 0;\par
    svg_begin(IMAGE_WIDTH, IMAGE_HEIGHT);\par
    size_t max_count = bins[0];\par
    for (size_t bin : bins)\par
    \{\par
        if (bin > max_count)\par
        \{\par
            max_count = bin;\par
        \}\par
    \}\par
\par
    if (max_count > MAX_COUNT)\par
    \{\par
\par
        const double scaling_factor = (double)MAX_COUNT / max_count;\par
\par
        for (size_t bin : bins)\par
        \{\par
            auto height = (size_t)(bin * scaling_factor);\par
            const double bin_width = BLOCK_WIDTH * height;\par
            svg_text(TEXT_LEFT, top + TEXT_BASELINE, to_string(bin));\par
            svg_rect(TEXT_WIDTH, top, bin_width, BIN_HEIGHT, "blue", "#ff2233", opacity_factor(bin, max_count));\par
            top += BIN_HEIGHT;\par
        \}\par
        svg_text(1, top + TEXT_BASELINE, make_info_text());\par
\par
        svg_end();\par
    \}\par
    else\par
    \{\par
        for (size_t bin : bins)\par
        \{\par
\par
            const double bin_width = BLOCK_WIDTH * bin;\par
            svg_text(TEXT_LEFT, top + TEXT_BASELINE, to_string(bin));\par
            svg_rect(TEXT_WIDTH, top, bin_width, BIN_HEIGHT, "blue", "#aaffaa", opacity_factor(bin, max_count));\par
            top += BIN_HEIGHT;\par
        \}\par
        svg_text(1, top + TEXT_BASELINE, make_info_text());\par
        svg_end();\par
\par
    \}\par
\par
\}\par
\par
\par
histogram.h\par
\par
#ifndef HISTOGRAM_H_INCLUDED\par
#define HISTOGRAM_H_INCLUDED\par
#include <vector>\par
\par
using namespace std;\par
\par
void find_minmax(const vector<double> numbers, double& min, double& max);\par
\par
struct Input \{\par
    vector<double> numbers;\par
    size_t bin_count;\par
\};\par
\par
void\par
show_histogram_text(const vector<size_t>& bins);\par
vector<double> input_numbers(size_t count);\par
vector<size_t> make_histogram(Input data);\par
\par
\par
\par
#endif // HISTOGRAM_H_INCLUDED\par
\par
\par
\par
svg.h\par
\par
#ifndef SVG_H_INCLUDED\par
#define SVG_H_INCLUDED\par
\par
#include <vector>\par
#include <string>\par
\par
\par
using namespace std;\par
void\par
svg_begin(double width, double height);\par
void\par
svg_end();\par
void\par
svg_text(double left, double baseline, string text);\par
\par
void svg_rect(double x, double y, double width, double height);\par
void svg_rect(double x, double y, double width, double height, string stroke = "black", string fill = "black");\par
\par
double\par
opacity_factor (size_t bin, size_t max_count);\par
\par
string\par
make_info_text();\par
\par
void\par
show_histogram_svg(const vector<size_t>& bins);\par
\par
#endif // SVG_H_INCLUDED\lang9\par
\par

\pard\sa200\sl276\slmult1\cf0\b0\i0\fs22\par
}
 